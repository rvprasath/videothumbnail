package com.videoDecoder.joinImage;

import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;

import javax.imageio.ImageIO;

import com.videoDecoder.createVideoFrame.CreateImageFrame;
import com.videoDecoder.createVideoFrame.FrameData;

/**
 * <code>ImageJoinProcess</code> class implements <code>ImageJoiner</code>
 * interface which contain abstract method that generates merged image from a
 * list of image frames which is generated by
 * <code>{@link CreateImageFrame}</code> along with the return values from
 * <code>CreateImageFrame</code>
 * 
 * @author Vishnu Prasath
 *
 */
public class ImageJoinProcess implements ImageJoiner {

	/**
	 * The constant variables for with defaults values which is used to take
	 * over the process if no user input is received other than
	 * <code>FrameData</code>
	 */
	private static final int DEFAULT_COLUMN_SIZE = 4;
	private static final int DEFAULT_ROW_SIZE = 30;
	private static final int DEFAULT_HEIGHT = 63;
	private static final int DEFAULT_WIDTH = 112;
	private static final String FIRST_POSTER = "first";
	private static final String MIDDLE_POSTER = "middle";
	private static final String LAST_POSTER = "last";

	/**
	 * Variables with global scope for image join process
	 */
	int heightPadding = 0, widthPadding = 0, j = 0, temp = 0, k = 0, JTemp = 0, count = 0;
	FrameData frameData;
	BufferedImage[] images;
	int column, row, height, width;
	private ImageJoinData imageJoinData = new ImageJoinData();
	private LinkedList<String> thumbNails = new LinkedList<String>();
	private ArrayList<String> posters = new ArrayList<String>();

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.videoDecoder.joinImage.ImageJoiner#generateMergedImage(com.
	 * videoDecoder.createVideoFrame.FrameData)
	 */
	@Override
	public ImageJoinData generateMergedImage(FrameData frameData) {
		try {
			BufferedImage[] images = generateBufferedImages(frameData, DEFAULT_COLUMN_SIZE, DEFAULT_ROW_SIZE,
					DEFAULT_HEIGHT, DEFAULT_WIDTH);
			this.frameData = frameData;
			this.images = images;
			this.column = DEFAULT_COLUMN_SIZE;
			this.row = DEFAULT_ROW_SIZE;
			this.height = DEFAULT_HEIGHT;
			this.width = DEFAULT_WIDTH;
			mergeBufferedImages();
			clearIndividualFrames();
			createJoinData();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return imageJoinData;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.videoDecoder.joinImage.ImageJoiner#generateMergedImage(com.
	 * videoDecoder.createVideoFrame.FrameData, int, int, int, int)
	 */
	@Override
	public ImageJoinData generateMergedImage(FrameData frameData, int column, int row, int height, int width) {
		try {
			BufferedImage[] images = generateBufferedImages(frameData, column, row, height, width);
			this.frameData = frameData;
			this.images = images;
			this.column = column;
			this.row = row;
			this.height = height;
			this.width = width;
			mergeBufferedImages();
			clearIndividualFrames();
			createJoinData();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return imageJoinData;
	}

	/**
	 * This <code>generateBufferedImages</code> method generates scaled buffer
	 * image for image join process
	 * 
	 * @param frameData
	 * @param column
	 * @param row
	 * @param height
	 * @param width
	 * @return BufferedImage[]
	 * @throws IOException
	 */
	private BufferedImage[] generateBufferedImages(FrameData frameData, int column, int row, int height, int width)
			throws IOException {

		BufferedImage images[] = new BufferedImage[frameData.getTotalFrameCount()];

		for (int i = 0; i < frameData.getTotalFrameCount(); i = (i + frameData.getSecondsPerFrame())) {
			File file = new File(
					frameData.getInputPath() + frameData.getOutputFileName() + i + "." + frameData.getImageFormat());
			BufferedImage image = ImageIO.read(file);
			Image imageDimension = image.getScaledInstance(width, height, Image.SCALE_SMOOTH);
			BufferedImage dimg = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
			Graphics2D g2d = dimg.createGraphics();
			g2d.drawImage(imageDimension, 0, 0, null);
			g2d.dispose();

			images[i] = dimg;
		}
		return images;
	}

	/**
	 * This <code>mergeBufferedImages</code> method process the buffered image
	 * and generate an image file contain a slide of images from video frames in
	 * horizontal and vertical manner. The recursive calling over
	 * <code>mergeBufferedImages</code> method produces the result of image file
	 * with horizontal and vertical image slides.
	 * 
	 * @throws IOException
	 */
	private void mergeBufferedImages() throws IOException {
		count++;
		BufferedImage mergedImage = new BufferedImage((width * column), (height * row), BufferedImage.TYPE_INT_RGB);
		Graphics2D g2d = mergedImage.createGraphics();
		for (j = 0; j < row; j++) {
			if (!(k < frameData.getTotalFrameCount())) {
				break;
			}
			for (int i = 0; i < column && k < frameData.getTotalFrameCount(); i++) {
				g2d.drawImage(images[k], widthPadding, heightPadding, null);
				widthPadding += images[0].getWidth();
				k += frameData.getSecondsPerFrame();
			}
			widthPadding = 0;
			heightPadding += images[0].getHeight();
		}
		g2d.dispose();
		String imageName = count + "." + frameData.getImageFormat();
		ImageIO.write(mergedImage, frameData.getImageFormat(), new File(frameData.getOutputPath() + "/" + imageName));
		thumbNails.add(imageName);
		if (k < frameData.getTotalFrameCount()) {
			widthPadding = 0;
			heightPadding = 0;
			mergeBufferedImages();
		}

	}

	/**
	 * This <code>clearIndividualFrames</code> method clears all the individual
	 * frames and generate posters for the video from start, middle and last
	 * frame
	 */
	private void clearIndividualFrames() {
		int j = 0;
		for (int i = 0; i < frameData.getTotalFrameCount(); i = (i + frameData.getSecondsPerFrame())) {
			if (j == 0 || j == (frameData.getRenderedFrame() / 2) || j == (frameData.getRenderedFrame() - 1)) {
				File old = new File(frameData.getOutputPath(),
						frameData.getOutputFileName() + i + "." + frameData.getImageFormat());
				if (j == 0) {
					File nw = new File(frameData.getOutputPath(), FIRST_POSTER + "." + frameData.getImageFormat());
					nw.delete();
					posters.add(FIRST_POSTER + "." + frameData.getImageFormat());
					old.renameTo(nw);
				} else if (j == (frameData.getRenderedFrame() / 2)) {
					File nw = new File(frameData.getOutputPath(), MIDDLE_POSTER + "." + frameData.getImageFormat());
					nw.delete();
					posters.add(MIDDLE_POSTER + "." + frameData.getImageFormat());
					old.renameTo(nw);
				} else {
					File nw = new File(frameData.getOutputPath(), LAST_POSTER + "." + frameData.getImageFormat());
					nw.delete();
					posters.add(LAST_POSTER + "." + frameData.getImageFormat());
					old.renameTo(nw);
				}
			} else {
				File file = new File(frameData.getOutputPath(),
						frameData.getOutputFileName() + i + "." + frameData.getImageFormat());
				if (!file.delete()) {
					System.out.println("FILE DELETION FAILED");
				}
			}
			j++;
		}
	}

	/**
	 * This <code>createJoinData</code> method create and
	 * <code>ImageJoinData</code> object with the absolute path, posters,
	 * thumbnails, seconds per frame, height, width, nh(number of horizontal
	 * slides i.e column) and nv(number of vertical slides i.e row)
	 */
	private void createJoinData() {
		imageJoinData.setAbsolutePath(frameData.getOutputPath());
		imageJoinData.setPosters(posters);
		imageJoinData.setThumbNails(thumbNails);
		imageJoinData.setSecPerFrames(frameData.getSecondsPerFrame());
		imageJoinData.setHeight(height);
		imageJoinData.setWidth(width);
		imageJoinData.setNh(column);
		imageJoinData.setNv(row);
	}

}
